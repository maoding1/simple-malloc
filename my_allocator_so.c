// my_allocator_so.c
// used to build a shared library that maps standard allocation functions and can used for benchmarking
// generated by gemini-2.5-pro

#include "mymalloc.h"
#include <string.h>
#include <stdio.h>
// 1. malloc - 直接映射
void* malloc(size_t size) {
    return mymalloc(size);
}

// 2. free - 直接映射
void free(void* ptr) {
    myfree(ptr);
}

// 3. calloc - 实现为 malloc + memset
void* calloc(size_t num, size_t size) {
    size_t total_size = num * size;
    // 防止乘法溢出 (在生产级代码中很重要)
    if (size != 0 && total_size / size != num) {
        return NULL;
    }
    
    void* ptr = mymalloc(total_size);
    if (ptr) {
        memset(ptr, 0, total_size);
    }
    return ptr;
}

// 4. realloc - 一个简单但功能正确的实现
void* realloc(void* ptr, size_t new_size) {
    if (ptr == NULL) {
        return mymalloc(new_size);
    }
    if (new_size == 0) {
        myfree(ptr);
        return NULL;
    }

    // 获取旧块的大小 - 这是难点，你的 allocator 需要提供这个能力
    // 我们通过 ptr 前一个位置的元数据来获取
    size_t* size_ptr = (size_t*)((char*)ptr - sizeof(size_t));
    size_t old_size_info = *size_ptr;
    size_t old_payload_size = (old_size_info & ~3UL) - sizeof(size_t);
    
    // 如果新尺寸小于等于旧尺寸，直接返回原指针（这是一个简化，实际可以缩减块）
    if (new_size <= old_payload_size) {
        return ptr;
    }
    
    // 分配新块，拷贝数据，释放旧块
    void* new_ptr = mymalloc(new_size);
    if (new_ptr) {
        memcpy(new_ptr, ptr, old_payload_size);
        myfree(ptr);
    }
    return new_ptr;
}

// benchmark 可能还会用到其他函数，先提供一些基础的
void* aligned_alloc(size_t alignment, size_t size) {
    // 我们的 allocator 默认就是16字节对齐，这里做个简化
    if (alignment <= 16) {
        return mymalloc(size);
    }
    // 完整的实现会更复杂
    return NULL;
}

size_t malloc_usable_size(void *ptr) {
    if (ptr == NULL) return 0;
    size_t* size_ptr = (size_t*)((char*)ptr - sizeof(size_t));
    size_t size_info = *size_ptr;
    return (size_info & -3UL) - sizeof(size_t);
}